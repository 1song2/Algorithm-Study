# 순위 검색

---

조합 + 이진탐색을 이용한 풀이.. 인데..
그렇게 했는데 내 풀이만 효율성에서 시간초과가 떴다. 수정 요망!

```swift
import Foundation

func solution(_ info:[String], _ query:[String]) -> [Int] {
    var dic = [String:[Int]]()
    var result = [Int]()
    dic["all"] = [Int]()
    
    for oneInfo in info {
        var splitedInfo = oneInfo.components(separatedBy: " ")
        let score = Int(splitedInfo.removeLast())!
        var allGroup = splitedInfo.combinationsWithoutRepetitionRemoved
        
        for group in allGroup {
            let groupKey = group.joined()
            if dic[groupKey] == nil {
                dic[groupKey] = [score]
            } else {
                dic[groupKey]!.append(score)
            }
        }
        
        dic["all"]!.append(score)
    }
    
    for condition in query {
        var splitedCondition = condition.components(separatedBy: " and ")
        let foodAndScore = splitedCondition.removeLast().components(separatedBy: " ")
        splitedCondition.append(foodAndScore[0])
        let group = splitedCondition.joined().components(separatedBy: "-").joined()
        
        if group == "" {
            result.append(dic["all"]!.count - lowerBound(arr: dic["all"]!.sorted(), start: 0, end: dic["all"]!.count, target: Int(foodAndScore[1])!))
            continue
        }
        if dic[group] == nil {
            result.append(0)
            continue
        } else {
            result.append(dic[group]!.count - lowerBound(arr: dic[group]!.sorted(), start: 0, end: dic[group]!.count, target: Int(foodAndScore[1])!))
        }
 
    }
    
    return result
}

func lowerBound(arr: [Int], start: Int, end: Int, target: Int) -> Int {
    var start = start
    var end = end
    
    while start < end {
        let mid = (start + end) / 2
        if arr[mid] < target {
            start = mid + 1
        } else {
            end = mid
        }
    }
    
    return end
}


extension Array {
    var combinationsWithoutRepetition: [[Element]] {
        guard !isEmpty else { return [[]] }
        return Array(self[1...]).combinationsWithoutRepetition.flatMap { [$0, [self[0]] + $0] }
    }
    
    var combinationsWithoutRepetitionRemoved: [[Element]] {
        var result = self.combinationsWithoutRepetition
        result.removeFirst()
        return result
    }
}


```

## 깨달은점

1. 딕셔너리 키값에 1억개 정도는 안전하게 넣을 수 있다. - JK  피셜 -
